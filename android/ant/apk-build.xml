<?xml version="1.0" encoding="UTF-8"?>
<!--
    Copyright (C) 2005-2008 The Android Open Source Project

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

<project name="android_rules" default="debug">

    <property-location name="out.dir" location="${OUT_DIR}" check-exists="false" />

    <path id="javac.srcdirs.additional">
      <filelist files="${ADDITIONAL_SRC_DIRS}"/>
      <filelist files="${GENERATED_SRC_DIRS}"/>
    </path>

    <!--
      Include additional resource folders in the apk, e.g. content/.../res.  We
      list the res folders in project.library.res.folder.path and the
      corresponding java packages in project.library.packages, which must be
      semicolon-delimited while ADDITIONAL_RES_PACKAGES is space-delimited, hence
      the javascript task.
    -->
    <path id="project.library.res.folder.path">
      <filelist files="${ADDITIONAL_RES_DIRS}"/>
    </path>
    <path id="project.library.bin.r.file.path">
      <filelist files="${ADDITIONAL_R_TEXT_FILES}"/>
    </path>
    <script language="javascript">
      var before = project.getProperty("ADDITIONAL_RES_PACKAGES");
      project.setProperty("project.library.packages", before.replaceAll(" ", ";"));
    </script>

    <property-value name="target.abi" value="${APP_ABI}"/>

    <!--
      We use the PROGUARD_ENABLED flag for enabling proguard. By default proguard is enabled for
      Release builds if proguard.config is set. Setting proguard.config even to an empty string will
      enable proguard. Set this property only when we have explicitly enabled proguard.
    -->
    <condition property="proguard.config" value="${PROGUARD_FLAGS}">
      <istrue value="${PROGUARD_ENABLED}"/>
    </condition>

    <!-- Set the output directory for the final apk to the ${apks.dir}. -->
    <property-location name="out.final.file"
        location="${apks.dir}/${ant.project.name}.apk"
        check-exists="false"/>

    <!-- Classpath for javac -->
    <path id="javac.custom.classpath">
      <filelist files="${INPUT_JARS_PATHS}"/>
    </path>

    <!--
      TODO(cjhopman): This is wrong for proguard builds. In that case, it should be just the
      obfuscated jar.
    -->
    <path id="out.dex.jar.input.ref">
      <path refid="javac.custom.classpath"/>
    </path>

    <path id="native.libs.gdbserver">
      <fileset file="${android.gdbserver}"/>
    </path>

    <!-- Disables automatic signing. -->
    <property name="build.is.signing.debug" value="false"/>

    <!-- ******************************************************* -->
    <!-- **************** Overridable Properties *************** -->
    <!-- ******************************************************* -->

    <!-- You can override these values in your build.xml or ant.properties.
         Overriding any other properties may result in broken build. -->

    <!-- Tells adb which device to target. You can change this from the command line
         by invoking "ant -Dadb.device.arg=-d" for device "ant -Dadb.device.arg=-e" for
         the emulator. -->
    <property name="adb.device.arg" value="" />

    <!-- fileset exclude patterns (space separated) to prevent
         files inside src/ from being packaged. -->
    <property name="android.package.excludes" value="" />

    <!-- set some properties used for filtering/override. If those weren't defined
         before, then this will create them with empty values, which are then ignored
         by the custom tasks receiving them. -->
    <property-value name="version.code" value="${APP_MANIFEST_VERSION_CODE}"/>
    <property-value name="version.name" value="${APP_MANIFEST_VERSION_NAME}"/>

    <property name="aapt.resource.filter" value="" />
    <!-- 'aapt.ignore.assets' is the list of file patterns to ignore under /res and /assets.
         Default is "!.svn:!.git:.*:<dir>_*:!CVS:!thumbs.db:!picasa.ini:!*.scc:*~"

         Overall patterns syntax is:
           [!][<dir>|<file>][*suffix-match|prefix-match*|full-match]:more:patterns...

         - The first character flag ! avoids printing a warning.
         - Pattern can have the flag "<dir>" to match only directories
           or "<file>" to match only files. Default is to match both.
         - Match is not case-sensitive.
    -->
    <property name="aapt.ignore.assets" value="" />

    <!-- dex force jumbo options, to be used when dex merging fails with
         UNEXPECTED TOP-LEVEL EXCEPTION: com.android.dx.util.DexException: Cannot handle conversion to jumbo index!
           at com.android.dx.merge.InstructionTransformer.jumboCheck(InstructionTransformer.java:103)
           ...
    -->
    <property name="dex.force.jumbo" value="false" />

    <!-- compilation options -->
    <property name="java.encoding" value="UTF-8" />
    <property name="java.target" value="1.5" />
    <property name="java.source" value="1.5" />
    <property name="java.compilerargs" value="" />

    <!-- manifest merger default value -->
    <property name="manifestmerger.enabled" value="false" />

    <!-- Verbosity -->
    <property name="verbose" value="false" />

    <!-- ******************************************************* -->
    <!-- ********************* Custom Tasks ******************** -->
    <!-- ******************************************************* -->

    <!-- jar file from where the tasks are loaded -->
    <path id="android.antlibs">
        <pathelement path="${sdk.dir}/tools/lib/anttasks.jar" />
    </path>

    <!-- Custom tasks -->
    <taskdef resource="anttasks.properties" classpathref="android.antlibs" />

    <!-- ******************************************************* -->
    <!-- ******************* Other Properties ****************** -->
    <!-- ******************************************************* -->
    <!-- overriding these properties may break the build
         unless the whole file is updated -->

    <!-- Input directories -->
    <property name="source.dir" value="src" />
    <property name="source.absolute.dir" location="${source.dir}" />
    <property-value name="gen.absolute.dir" value="${out.dir}/gen"/>
    <property name="resource.absolute.dir" value="${RESOURCE_DIR}"/>
    <property name="asset.dir" value="assets" />
    <condition property="asset.absolute.dir"
        value="${out.dir}/assets"
        else="${ASSET_DIR}">
      <equals arg1="${ASSET_DIR}" arg2=""/>
    </condition>

    <property name="jar.libs.dir" value="libs" />
    <property name="jar.libs.absolute.dir" location="${jar.libs.dir}" />
    <property-location name="native.libs.absolute.dir" location="${out.dir}/libs"
        check-exists="false"/>

    <property name="manifest.file" value="AndroidManifest.xml" />
    <property name="manifest.abs.file" location="${manifest.file}" />

    <!-- Output directories -->
    <property name="out.dir" value="bin" />
    <property name="out.absolute.dir" location="${out.dir}" />
    <property name="out.classes.absolute.dir" location="${out.dir}/classes" />
    <property name="out.res.absolute.dir" location="${out.dir}/res" />
    <property name="out.aidl.absolute.dir" location="${out.dir}/aidl" />
    <property name="out.dexed.absolute.dir" location="${out.dir}/dexedLibs" />
    <property name="out.manifest.abs.file" location="${out.dir}/AndroidManifest.xml" />

    <!-- tools location -->
    <property name="android.tools.dir" location="${sdk.dir}/tools" />
    <property name="android.platform.tools.dir" location="${sdk.dir}/platform-tools" />
    <property name="exe" value="" />
    <property name="bat" value="" />
    <property name="adb" location="${android.platform.tools.dir}/adb${exe}" />
    <property name="zipalign" location="${android.tools.dir}/zipalign${exe}" />
    <property name="aidl" location="${android.platform.tools.dir}/aidl${exe}" />
    <property name="aapt" location="${android.platform.tools.dir}/aapt${exe}" />
    <property name="dx" location="${android.platform.tools.dir}/dx${bat}" />

    <!-- Intermediate files -->
    <property name="dex.file.name" value="classes.dex" />
    <property name="intermediate.dex.file" location="${out.absolute.dir}/${dex.file.name}" />
    <property name="resource.package.file.name" value="${ant.project.name}.ap_" />

    <!-- Build property file -->
    <property name="out.build.prop.file" location="${out.absolute.dir}/build.prop" />

    <!--
      For debug builds, the Android SDK tools create a key in ~/.android and sign the build with it.
      This has caused all kinds of issues. Instead, the debug build should be signed with a key in
      build/android/ant. The SDK tools do not provide any support for overriding that behavior and so
      instead one must use the hack below.
    -->
    <property name="key.store" value="${CHROMIUM_SRC}/build/android/ant/chromium-debug.keystore"/>
    <property name="key.store.password" value="chromium"/>
    <property name="key.alias" value="chromiumdebugkey"/>
    <property name="key.alias.password" value="chromium"/>

    <!-- properties for packaging -->
    <property name="build.packaging.nocrunch" value="true" />

    <!-- whether we need to fork javac.
         This is only needed on Windows when running Java < 7 -->
    <condition else="false" property="need.javac.fork">
        <and>
            <matches pattern="1\.[56]" string="${java.specification.version}"/>
            <not>
                <os family="unix"/>
            </not>
        </and>
    </condition>

    <!-- ******************************************************* -->
    <!-- ************************ Macros *********************** -->
    <!-- ******************************************************* -->

    <!-- macro to do a task on if project.is.library is false.
         elseText attribute is displayed otherwise -->
    <macrodef name="do-only-if-not-library">
        <attribute name="elseText" />
        <element name="task-to-do" implicit="yes" />
        <sequential>
        <if condition="${project.is.library}">
            <else>
                <task-to-do />
            </else>
            <then>
                <echo level="info">@{elseText}</echo>
            </then>
        </if>
        </sequential>
    </macrodef>

    <!-- macro to do a task on if manifest.hasCode is true.
         elseText attribute is displayed otherwise -->
    <macrodef name="do-only-if-manifest-hasCode">
        <attribute name="elseText" default=""/>
        <element name="task-to-do" implicit="yes" />
        <sequential>
        <if condition="${manifest.hasCode}">
            <then>
                <task-to-do />
            </then>
            <else>
                <if>
                    <condition>
                        <length string="@{elseText}" trim="true" when="greater" length="0" />
                    </condition>
                    <then>
                        <echo level="info">@{elseText}</echo>
                    </then>
                </if>
            </else>
        </if>
        </sequential>
    </macrodef>


    <!-- Configurable macro, which allows to pass as parameters output directory,
         output dex filename and external libraries to dex (optional) -->
    <macrodef name="dex-helper">
        <element name="external-libs" optional="yes" />
        <attribute name="nolocals" default="false" />
        <sequential>
            <!-- sets the primary input for dex. If a pre-dex task sets it to
                 something else this has no effect -->
            <property name="out.dex.input.absolute.dir" value="${out.classes.absolute.dir}" />

            <dex executable="${dx}"
                    output="${intermediate.dex.file}"
                    dexedlibs="${out.dexed.absolute.dir}"
                    nolocals="@{nolocals}"
                    forceJumbo="${dex.force.jumbo}"
                    verbose="${verbose}">
                <path path="${out.dex.input.absolute.dir}"/>
                <path refid="out.dex.jar.input.ref" />
                <external-libs />
            </dex>
        </sequential>
    </macrodef>

    <!-- This is macro that enable passing variable list of external jar files to ApkBuilder
         Example of use:
         <package-helper>
             <extra-jars>
                <jarfolder path="my_jars" />
                <jarfile path="foo/bar.jar" />
                <jarfolder path="your_jars" />
             </extra-jars>
         </package-helper> -->
    <macrodef name="package-helper">
        <element name="extra-jars" optional="yes" />
        <sequential>
            <apkbuilder
                    outfolder="${out.absolute.dir}"
                    resourcefile="${resource.package.file.name}"
                    apkfilepath="${out.packaged.file}"
                    debugpackaging="${build.is.packaging.debug}"
                    debugsigning="${build.is.signing.debug}"
                    verbose="${verbose}"
                    hascode="${manifest.hasCode}"
                    previousBuildType="${build.last.is.packaging.debug}/${build.last.is.signing.debug}"
                    buildType="${build.is.packaging.debug}/${build.is.signing.debug}">
                <dex path="${intermediate.dex.file}"/>
                <sourcefolder path="${source.absolute.dir}"/>
                <nativefolder path="${native.libs.absolute.dir}" />
                <extra-jars/>
            </apkbuilder>
        </sequential>
    </macrodef>

    <!-- This is macro which zipaligns in.package and outputs it to out.package. Used by targets
         debug and release.-->
    <macrodef name="zipalign-helper">
        <attribute name="in.package" />
        <attribute name="out.package" />
        <sequential>
            <zipalign
                    executable="${zipalign}"
                    input="@{in.package}"
                    output="@{out.package}"
                    verbose="${verbose}" />
        </sequential>
    </macrodef>

    <macrodef name="record-build-key">
        <attribute name="key" default="false" />
        <attribute name="value" default="false" />
        <sequential>
            <propertyfile file="${out.build.prop.file}" comment="Last build type">
                <entry key="@{key}" value="@{value}"/>
            </propertyfile>
        </sequential>
    </macrodef>

    <macrodef name="record-build-info">
        <sequential>
            <record-build-key key="build.last.target" value="${build.target}" />
            <record-build-key key="build.last.is.instrumented" value="${build.is.instrumented}" />
            <record-build-key key="build.last.is.packaging.debug" value="${build.is.packaging.debug}" />
            <record-build-key key="build.last.is.signing.debug" value="${build.is.signing.debug}" />
        </sequential>
    </macrodef>

    <macrodef name="uninstall-helper">
        <attribute name="app.package" default="false" />
        <sequential>
            <echo level="info">Uninstalling @{app.package} from the default emulator or device...</echo>
            <exec executable="${adb}" failonerror="true">
                <arg line="${adb.device.arg}" />
                <arg value="uninstall" />
                <arg value="@{app.package}" />
            </exec>
        </sequential>
    </macrodef>

    <!-- ******************************************************* -->
    <!-- ******************** Build Targets ******************** -->
    <!-- ******************************************************* -->

    <!-- Basic Ant + SDK check -->
    <target name="-check-env">
        <checkenv />
    </target>

    <!-- generic setup -->
    <target name="-setup" depends="-check-env">
        <echo level="info">Project Name: ${ant.project.name}</echo>
        <gettype projectTypeOut="project.type" />

        <!-- sets a few boolean based on project.type
             to make the if task easier -->
        <condition property="project.is.library" value="true" else="false">
            <equals arg1="${project.type}" arg2="library" />
        </condition>
        <condition property="project.is.test" value="true" else="false">
            <equals arg1="${project.type}" arg2="test" />
        </condition>
        <condition property="project.is.testapp" value="true" else="false">
            <equals arg1="${project.type}" arg2="test-app" />
        </condition>

        <!-- If a test project, resolve absolute path to tested project. -->
        <if condition="${project.is.test}">
            <then>
                <property name="tested.project.absolute.dir" location="${tested.project.dir}" />
            </then>
        </if>

        <!-- get the project manifest package -->
        <xpath input="${manifest.abs.file}"
                expression="/manifest/@package" output="project.app.package" />

    </target>

    <!-- empty default pre-clean target. Create a similar target in
         your build.xml and it'll be called instead of this one. -->
    <target name="-pre-clean"/>

    <!-- clean target -->
    <target name="clean" depends="-setup, -pre-clean"
            description="Removes output files created by other targets.">
        <delete dir="${out.absolute.dir}" verbose="${verbose}" />
        <delete dir="${gen.absolute.dir}" verbose="${verbose}" />

        <!-- if we know about a tested project or libraries, we clean them too. -->
        <if condition="${project.is.test}">
            <then>
                <property name="tested.project.absolute.dir" location="${tested.project.dir}" />
                <subant failonerror="true">
                    <fileset dir="${tested.project.absolute.dir}" includes="build.xml" />
                    <target name="clean" />
                </subant>
            </then>
        </if>

    </target>

    <!-- Pre build setup -->
    <target name="-build-setup" depends="-setup">

        <!-- read the previous build mode -->
        <property file="${out.build.prop.file}" />
        <!-- if empty the props won't be set, meaning it's a new build.
             To force a build, set the prop to empty values. -->
        <property name="build.last.target" value="" />
        <property name="build.last.is.instrumented" value="" />
        <property name="build.last.is.packaging.debug" value="" />
        <property name="build.last.is.signing.debug" value="" />

        <!-- If the "debug" build type changed, clear out the compiled code.
             This is to make sure the new BuildConfig.DEBUG value is picked up
             as javac can't deal with this type of change in its dependency computation. -->
        <if>
            <condition>
                <and>
                    <length string="${build.last.is.packaging.debug}" trim="true" when="greater" length="0" />
                    <not><equals
                            arg1="${build.is.packaging.debug}"
                            arg2="${build.last.is.packaging.debug}" /></not>
                </and>
            </condition>
            <then>
                <echo level="info">Switching between debug and non debug build: Deleting previous compilation output...</echo>
                <delete dir="${out.classes.absolute.dir}" verbose="${verbose}" />
            </then>
            <else>
                <!-- Else, we may still need to clean the code, for another reason.
                     special case for instrumented: if the previous build was
                     instrumented but not this one, clear out the compiled code -->
                <if>
                    <condition>
                        <and>
                            <istrue value="${build.last.is.instrumented}" />
                            <isfalse value="${build.is.instrumented}" />
                        </and>
                    </condition>
                    <then>
                        <echo level="info">Switching from instrumented to non-instrumented build: Deleting previous compilation output...</echo>
                        <delete dir="${out.classes.absolute.dir}" verbose="${verbose}" />
                    </then>
                </if>
            </else>
        </if>

        <echo level="info">Resolving Build Target for ${ant.project.name}...</echo>
        <!-- load project properties, resolve Android target, library dependencies
             and set some properties with the results.
             All property names are passed as parameters ending in -Out -->
        <gettarget
                androidJarFileOut="project.target.android.jar"
                androidAidlFileOut="project.target.framework.aidl"
                bootClassPathOut="project.target.class.path"
                targetApiOut="project.target.apilevel"
                minSdkVersionOut="project.minSdkVersion" />

        <!-- Value of the hasCode attribute (Application node) extracted from manifest file -->
        <xpath input="${manifest.abs.file}" expression="/manifest/application/@android:hasCode"
                    output="manifest.hasCode" default="true"/>

        <echo level="info">----------</echo>
        <echo level="info">Creating output directories if needed...</echo>
        <mkdir dir="${resource.absolute.dir}" />
        <mkdir dir="${jar.libs.absolute.dir}" />
        <mkdir dir="${out.absolute.dir}" />
        <mkdir dir="${out.res.absolute.dir}" />
        <do-only-if-manifest-hasCode>
            <mkdir dir="${gen.absolute.dir}" />
            <mkdir dir="${out.classes.absolute.dir}" />
            <mkdir dir="${out.dexed.absolute.dir}" />
        </do-only-if-manifest-hasCode>
    </target>

    <!-- empty default pre-build target. Create a similar target in
         your build.xml and it'll be called instead of this one. -->
    <target name="-pre-build"/>

    <!-- Code Generation: compile resources (aapt -> R.java), aidl -->
    <target name="-code-gen">
        <!-- always merge manifest -->
        <mergemanifest
                appManifest="${manifest.abs.file}"
                outManifest="${out.manifest.abs.file}"
                enabled="${manifestmerger.enabled}">
        </mergemanifest>

        <do-only-if-manifest-hasCode
                elseText="hasCode = false. Skipping aidl/R.java">
            <echo level="info">----------</echo>
            <echo level="info">Handling Resources...</echo>
            <aapt executable="${aapt}"
                    command="package"
                    verbose="${verbose}"
                    manifest="${out.manifest.abs.file}"
                    androidjar="${project.target.android.jar}"
                    rfolder="${gen.absolute.dir}"
                    nonConstantId="${android.library}"
                    libraryResFolderPathRefid="project.library.res.folder.path"
                    libraryPackagesRefid="project.library.packages"
                    libraryRFileRefid="project.library.bin.r.file.path"
                    ignoreAssets="${aapt.ignore.assets}"
                    binFolder="${out.absolute.dir}"
                    proguardFile="${out.absolute.dir}/proguard.txt">
                <res path="${out.res.absolute.dir}" />
                <res path="${resource.absolute.dir}" />
            </aapt>

            <echo level="info">----------</echo>
            <echo level="info">Handling BuildConfig class...</echo>
            <buildconfig
                    genFolder="${gen.absolute.dir}"
                    package="${project.app.package}"
                    buildType="${build.is.packaging.debug}"
                    previousBuildType="${build.last.is.packaging.debug}"/>

        </do-only-if-manifest-hasCode>
    </target>

    <!-- empty default pre-compile target. Create a similar target in
         your build.xml and it'll be called instead of this one. -->
    <target name="-pre-compile">
      <!--
        Remove all .class files from the output directory. This prevents inclusion of incorrect .class
        files in the final apk. For example, if a .java file was deleted, the apk should not contain
        the .class files for that .java from previous builds.
      -->
      <delete>
        <fileset dir="${out.classes.absolute.dir}" includes="**/*.class"/>
      </delete>
    </target>

    <!--
      Override the -compile target.
      This target requires 'javac.custom.classpath' to be set to reference
      of classpath to be used for javac. Also accepts custom path for
      sources: 'javac.custom.sourcepath'.
    -->
    <!-- Compiles this project's .java files into .class files. -->
    <target
        name="-compile"
        depends="-build-setup, -pre-build, -code-gen, -pre-compile">
      <do-only-if-manifest-hasCode elseText="hasCode = false. Skipping..." >
        <javac
            bootclasspathref="project.target.class.path"
            classpathref="javac.custom.classpath"
            debug="true"
            destdir="${out.classes.absolute.dir}"
            encoding="${java.encoding}"
            extdirs=""
            fork="${need.javac.fork}"
            includeantruntime="false"
            source="${java.source}"
            target="${java.target}"
            verbose="${verbose}">
          <src path="${source.absolute.dir}"/>
          <src path="${gen.absolute.dir}"/>
          <src>
            <path refid="javac.srcdirs.additional"/>
          </src>
          <compilerarg value="-Xlint:unchecked"/>
          <compilerarg line="${java.compilerargs}"/>
        </javac>
        <!--
          If the project needs a test jar then generate a jar containing
          all compiled classes and referenced jars.
          project.is.testapp is set by Android's ant build system based on the
          target's manifest. It is true only for instrumentation apks.
        -->
        <if condition="${project.is.testapp}">
          <then>
            <property-location name="create.test.jar.file"
                location="${CHROMIUM_SRC}/build/android/ant/create-test-jar.js"/>
            <script language="javascript" src="${create.test.jar.file}"/>
          </then>
        </if>

      </do-only-if-manifest-hasCode>
    </target>

    <!-- empty default post-compile target. Create a similar target in
         your build.xml and it'll be called instead of this one. -->
    <target name="-post-compile">
      <!--
        Copy gdbserver to main libs directory if building a non-instrumentation debug apk.
      -->
      <if>
        <condition>
          <and>
            <equals arg1="${build.target}" arg2="debug"/>
            <isfalse value="${project.is.testapp}"/>
          </and>
        </condition>
        <then>
          <copy todir="${out.dir}/libs/${target.abi}">
            <path refid="native.libs.gdbserver"/>
          </copy>
        </then>
      </if>

      <!-- Package all the compiled .class files into a .jar. -->
      <jar
        jarfile="${lib.java.dir}/${JAR_NAME}"
        basedir="${out.classes.absolute.dir}"
      />
    </target>


    <!-- Obfuscate target
        This is only active in release builds when proguard.config is defined
        in default.properties.

        To replace Proguard with a different obfuscation engine:
        Override the following targets in your build.xml, before the call to <setup>
            -release-obfuscation-check
                Check whether obfuscation should happen, and put the result in a property.
            -debug-obfuscation-check
                Obfuscation should not happen. Set the same property to false.
            -obfuscate
                check if the property set in -debug/release-obfuscation-check is set to true.
                If true:
                    Perform obfuscation
                    Set property out.dex.input.absolute.dir to be the output of the obfuscation
    -->
    <!--
      Override obfuscate target to pass javac.custom.classpath to Proguard. SDK tools do not provide
      any way to pass custom class paths to Proguard.
     -->
    <target name="-obfuscate">
      <if condition="${proguard.enabled}">
        <then>
          <property name="obfuscate.absolute.dir" location="${out.absolute.dir}/proguard"/>
          <property name="preobfuscate.jar.file" value="${obfuscate.absolute.dir}/original.jar"/>
          <property name="obfuscated.jar.file" value="${obfuscate.absolute.dir}/obfuscated.jar"/>
          <!-- input for dex will be proguard's output -->
          <property name="out.dex.input.absolute.dir" value="${obfuscated.jar.file}"/>

          <!-- Add Proguard Tasks -->
          <property name="proguard.jar" location="${android.tools.dir}/proguard/lib/proguard.jar"/>
          <taskdef name="proguard" classname="proguard.ant.ProGuardTask" classpath="${proguard.jar}"/>

          <!-- Set the android classpath Path object into a single property. It'll be
                   all the jar files separated by a platform path-separator.
                   Each path must be quoted if it contains spaces.
          -->
          <pathconvert property="project.target.classpath.value" refid="project.target.class.path">
            <firstmatchmapper>
              <regexpmapper from='^([^ ]*)( .*)$$' to='"\1\2"'/>
              <identitymapper/>
            </firstmatchmapper>
          </pathconvert>

          <!-- Build a path object with all the jar files that must be obfuscated.
               This include the project compiled source code and any 3rd party jar
               files. -->
          <path id="project.all.classes.path">
            <pathelement location="${preobfuscate.jar.file}"/>
            <!-- Pass javac.custom.classpath for apks. -->
            <path refid="javac.custom.classpath"/>
          </path>
          <!-- Set the project jar files Path object into a single property. It'll be
               all the jar files separated by a platform path-separator.
               Each path must be quoted if it contains spaces.
          -->
          <pathconvert property="project.all.classes.value" refid="project.all.classes.path">
            <firstmatchmapper>
              <regexpmapper from='^([^ ]*)( .*)$$' to='"\1\2"'/>
              <identitymapper/>
            </firstmatchmapper>
          </pathconvert>

          <!-- Turn the path property ${proguard.config} from an A:B:C property
               into a series of includes: -include A -include B -include C
               suitable for processing by the ProGuard task. Note - this does
               not include the leading '-include "' or the closing '"'; those
               are added under the <proguard> call below.
          -->
          <path id="proguard.configpath">
            <pathelement path="${proguard.config}"/>
          </path>
          <pathconvert pathsep='" -include "' property="proguard.configcmd"
            refid="proguard.configpath"/>

          <mkdir   dir="${obfuscate.absolute.dir}"/>
          <delete file="${preobfuscate.jar.file}"/>
          <delete file="${obfuscated.jar.file}"/>
          <jar basedir="${out.classes.absolute.dir}"
            destfile="${preobfuscate.jar.file}"/>
          <proguard>
            -include      "${proguard.configcmd}"
            -include      "${out.absolute.dir}/proguard.txt"
            -injars       ${project.all.classes.value}
            -outjars      "${obfuscated.jar.file}"
            -libraryjars  ${project.target.classpath.value}
            -dump         "${obfuscate.absolute.dir}/dump.txt"
            -printseeds   "${obfuscate.absolute.dir}/seeds.txt"
            -printusage   "${obfuscate.absolute.dir}/usage.txt"
            -printmapping "${obfuscate.absolute.dir}/mapping.txt"
          </proguard>
        </then>
      </if>
    </target>

    <!-- Converts this project's .class files into .dex files -->
    <target name="-dex" depends="-compile, -post-compile, -obfuscate">
        <do-only-if-manifest-hasCode elseText="hasCode = false. Skipping...">
            <!-- only convert to dalvik bytecode is *not* a library -->
            <do-only-if-not-library elseText="Library project: do not convert bytecode..." >
                <dex-helper />
            </do-only-if-not-library>
        </do-only-if-manifest-hasCode>
    </target>

<!-- Updates the pre-processed PNG cache -->
    <target name="-crunch">
        <exec executable="${aapt}" taskName="crunch">
            <arg value="crunch" />
            <arg value="-v" />
            <arg value="-S" />
            <arg path="${resource.absolute.dir}" />
            <arg value="-C" />
            <arg path="${out.res.absolute.dir}" />
        </exec>
    </target>

    <!-- Puts the project's resources into the output package file
         This actually can create multiple resource package in case
         Some custom apk with specific configuration have been
         declared in default.properties.
         -->
    <target name="-package-resources" depends="-crunch">
        <!-- only package resources if *not* a library project -->
        <do-only-if-not-library elseText="Library project: do not package resources..." >
            <aapt executable="${aapt}"
                    command="package"
                    versioncode="${version.code}"
                    versionname="${version.name}"
                    debug="${build.is.packaging.debug}"
                    manifest="${out.manifest.abs.file}"
                    assets="${asset.absolute.dir}"
                    androidjar="${project.target.android.jar}"
                    apkfolder="${out.absolute.dir}"
                    nocrunch="${build.packaging.nocrunch}"
                    resourcefilename="${resource.package.file.name}"
                    resourcefilter="${aapt.resource.filter}"
                    libraryResFolderPathRefid="project.library.res.folder.path"
                    libraryPackagesRefid="project.library.packages"
                    libraryRFileRefid="project.library.bin.r.file.path"
                    previousBuildType="${build.last.target}"
                    buildType="${build.target}"
                    ignoreAssets="${aapt.ignore.assets}">
                <res path="${out.res.absolute.dir}" />
                <res path="${resource.absolute.dir}" />
                <!-- <nocompress /> forces no compression on any files in assets or res/raw -->
                <!-- <nocompress extension="xml" /> forces no compression on specific file extensions in assets and res/raw -->
            </aapt>
        </do-only-if-not-library>
    </target>

    <!-- Packages the application. -->
    <target name="-package" depends="-dex, -package-resources">
        <!-- only package apk if *not* a library project -->
        <do-only-if-not-library elseText="Library project: do not package apk..." >
            <package-helper />
        </do-only-if-not-library>
    </target>

    <target name="-post-package" />
    <target name="-post-build" />

    <target name="-set-mode-check">
        <fail if="build.is.mode.set"
                message="Cannot run two different modes at the same time. If you are running more than one debug/release/instrument type targets, call them from different Ant calls." />
    </target>

    <!-- ******************************************************* -->
    <!-- **************** Debug specific targets *************** -->
    <!-- ******************************************************* -->

    <target name="-set-debug-files" depends="-set-mode-check">

        <property name="out.packaged.file" location="${out.absolute.dir}/${ant.project.name}-debug-unaligned.apk" />
        <property name="out.final.file" location="${out.absolute.dir}/${ant.project.name}-debug.apk" />
        <property name="build.is.mode.set" value="true" />
    </target>


    <target name="-set-debug-mode" depends="-setup">
        <!-- record the current build target -->
        <property name="build.target" value="debug" />

        <property name="build.is.instrumented" value="false" />

        <!-- whether the build is a debug build. always set. -->
        <property name="build.is.packaging.debug" value="true" />

        <!-- signing mode: debug -->
        <property name="build.is.signing.debug" value="true" />
    </target>

    <target name="-debug-obfuscation-check">
        <!-- proguard is never enabled in debug mode -->
        <property name="proguard.enabled" value="false"/>
    </target>

    <!-- SDK tools assume that out.packaged.file is signed and name it "...-unaligned" -->
    <property name="out.packaged.file"
      value="${apks.dir}/${ant.project.name}-unsigned.apk" />
    <property name="out.unaligned.file"
      value="${apks.dir}/${ant.project.name}-unaligned.apk" />

    <!-- By default, the SDK tools build only aligns the APK in the -do-debug target. -->
    <!-- Builds debug output package -->
    <target name="-do-sign"
        depends="-package, -post-package">
      <sequential>
        <!-- Signs the APK -->
        <echo level="info">Signing final apk...</echo>
        <signapk
          input="${out.packaged.file}"
          output="${out.unaligned.file}"
          keystore="${key.store}"
          storepass="${key.store.password}"
          alias="${key.alias}"
          keypass="${key.alias.password}"/>

        <!-- Zip aligns the APK -->
        <zipalign-helper
          in.package="${out.unaligned.file}"
          out.package="${out.final.file}" />
        <echo level="info">Release Package: ${out.final.file}</echo>
      </sequential>
    </target>

    <target name="-do-debug"
      depends="-set-debug-mode, -debug-obfuscation-check, -do-sign">
      <record-build-info />
    </target>

    <!-- Builds debug output package -->
    <target name="debug" depends="-set-debug-files, -do-debug, -post-build"
                description="Builds the application and signs it with a debug key.">
    </target>

    <!-- ******************************************************* -->
    <!-- *************** Release specific targets ************** -->
    <!-- ******************************************************* -->

    <target name="-release-obfuscation-check">
        <echo level="info">proguard.config is ${proguard.config}</echo>
        <condition property="proguard.enabled" value="true" else="false">
            <and>
                <isset property="build.is.mode.release" />
                <isset property="proguard.config" />
            </and>
        </condition>
        <if condition="${proguard.enabled}">
            <then>
                <echo level="info">Proguard.config is enabled</echo>
                <!-- Secondary dx input (jar files) is empty since all the
                     jar files will be in the obfuscated jar -->
                <path id="out.dex.jar.input.ref" />
            </then>
        </if>
    </target>

    <target name="-set-release-mode" depends="-set-mode-check">
        <property name="out.packaged.file" location="${out.absolute.dir}/${ant.project.name}-release-unsigned.apk" />
        <property name="out.final.file" location="${out.absolute.dir}/${ant.project.name}-release.apk" />
        <property name="build.is.mode.set" value="true" />

        <!-- record the current build target -->
        <property name="build.target" value="release" />

        <property name="build.is.instrumented" value="false" />

        <!-- release mode is only valid if the manifest does not explicitly
             set debuggable to true. default is false. -->
        <xpath input="${manifest.abs.file}" expression="/manifest/application/@android:debuggable"
                output="build.is.packaging.debug" default="false"/>

        <!-- signing mode: release -->
        <property name="build.is.signing.debug" value="false" />

        <if condition="${build.is.packaging.debug}">
            <then>
                <echo>*************************************************</echo>
                <echo>****  Android Manifest has debuggable=true   ****</echo>
                <echo>**** Doing DEBUG packaging with RELEASE keys ****</echo>
                <echo>*************************************************</echo>
            </then>
            <else>
                <!-- property only set in release mode.
                     Useful for if/unless attributes in target node
                     when using Ant before 1.8 -->
                <property name="build.is.mode.release" value="true"/>
            </else>
        </if>
    </target>

    <target name="-release-sign" depends="-do-sign" >
        <record-build-info />
    </target>

    <!-- This runs -package-release first and then runs
         only if release-sign is true (set in -release-check,
         called by -release-no-sign)-->
    <target name="release"
                depends="-set-release-mode, -release-obfuscation-check, -package, -post-package, -release-sign, -post-build"
                description="Builds the application in release mode.">
    </target>

</project>
