#!/usr/bin/env python
#
# Copyright 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Symbolizes stack traces generated by Chromium for Android.

Sample usage:
  adb logcat chromium:V | symbolize.py
"""

import os
import re
import sys

from pylib import constants

# Uses symbol.py from third_party/android_platform, not python's.
sys.path.insert(0,
                os.path.join(constants.DIR_SOURCE_ROOT,
                            'third_party/android_platform/development/scripts'))
import symbol

# Sample output from base/debug/stack_trace_android.cc
#00 0x693cd34f /path/to/some/libfoo.so+0x0007434f
TRACE_LINE = re.compile('(?P<frame>\#[0-9]+ 0x[0-9a-f]{8,8}) '
                        '(?P<lib>[^+]+)\+0x(?P<addr>[0-9a-f]{8,8})')

class Symbolizer(object):
  def __init__(self, file_in, file_out):
    self.file_in = file_in
    self.file_out = file_out

  def ProcessInput(self):
    for line in self.file_in:
      match = re.search(TRACE_LINE, line)
      if not match:
        self.file_out.write(line)
        self.file_out.flush()
        continue

      frame = match.group('frame')
      lib = match.group('lib')
      addr = match.group('addr')

      # TODO(scherkus): Doing a single lookup per line is pretty slow,
      # especially with larger libraries. Consider caching strategies such as:
      # 1) Have Python load the libraries and do symbol lookups instead of
      #    calling out to addr2line each time.
      # 2) Have Python keep multiple addr2line instances open as subprocesses,
      #    piping addresses and reading back symbols as we find them
      # 3) Read ahead the entire stack trace until we find no more, then batch
      #    the symbol lookups.
      #
      # TODO(scherkus): These results are memoized, which could result in
      # incorrect lookups when running this script on long-lived instances
      # (e.g., adb logcat) when doing incremental development. Consider clearing
      # the cache when modification timestamp of libraries change.
      sym = symbol.SymbolInformation(lib, addr, False)[0][0]

      if not sym:
        self.file_out.write(line)
        self.file_out.flush()
        continue

      pre = line[0:match.start('frame')]
      post = line[match.end('addr'):]

      self.file_out.write(pre)
      self.file_out.write(frame)
      self.file_out.write(' ')
      self.file_out.write(sym)
      self.file_out.write(post)
      self.file_out.flush()


def main():
  symbolizer = Symbolizer(sys.stdin, sys.stdout)
  symbolizer.ProcessInput()


if __name__ == '__main__':
  main()
