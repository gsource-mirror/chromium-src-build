# Copyright 2021 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/toolchain/apple/toolchain.gni")
if (build_with_chromium) {
  import("//tools/json_data_generator/json_data_generator.gni")
}

# Defines a template for Swift source files. The default module_name
# of the target is the entire target label (without the leading //)
# with all "/" and ":" replaced with "_".
#
# Arguments
#
#   generate_intents
#       (optional) boolean, if true, intents definition in the source code
#       will be parsed when generating the final application (if it enable
#       the extraction of intents metadata), defaults to false.
#   module_name
#       (optional) string, name of this build target's top level swift module.
#       If not specified, a module name will be generated based on the target's
#       names
#
template("swift_source_set") {
  _generate_intents = false
  if (defined(invoker.generate_intents)) {
    _generate_intents = invoker.generate_intents
  }

  _target_name = target_name
  not_needed([ "_target_name" ])
  source_set(target_name) {
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    if (!defined(module_name)) {
      _target_label = get_label_info(":$_target_name", "label_no_toolchain")

      # Strip the // from the beginning of the label.
      _target_label = string_replace(_target_label, "//", "", 1)
      module_name =
          string_replace(string_replace(_target_label, "/", "_"), ":", "_")
    }

    # If generate_intents is true, write file $target_name.module_info.json
    # with information about the module used by extract_metadata.py script.
    if (_generate_intents) {
      _output_path = "$target_out_dir/$target_name"
      _swift_files = sources
      _const_files = []
      if (swift_whole_module_optimization) {
        _const_files += [ "$_output_path/$module_name.swiftconstvalues" ]
      } else {
        foreach(_source, sources) {
          _const_files += [ "$_output_path/" + get_path_info(_source, "name") +
                            ".swiftconstvalues" ]
        }
      }

      _module_info = {
        module_name = module_name
        swift_files = rebase_path(_swift_files, root_build_dir)
        const_files = rebase_path(_const_files, root_build_dir)
      }

      # Write the information for the module using `write_file(...)`.
      write_file("$_output_path.module_info.json", _module_info, "json")
    }

    # C++ and obj-C++ targets with a direct dependency on a swift_source_set
    # need to be able to indirectly include headers from the SDK.
    public_configs = [ "//build/config/ios:swift_cxx_interop_includes" ]
  }
}

set_defaults("swift_source_set") {
  configs = default_compiler_configs
}

if (enable_swift_cxx_interop) {
  # Template that defines a modulemap for exposing symbols from C++ sources to
  # swift.
  #
  # Arguments
  #
  #   modules:
  #       Array of scopes. Each scope has the following arguments:
  #       name:
  #           String, the name of the module.
  #       sources:
  #           Array of strings, list of C++ header files to be imported.
  #       apinotes:
  #           (optional) Array of strings, paths of apinotes files.
  template("swift_modulemap") {
    assert(defined(invoker.modules),
           "'modules' must be defined in swift_modulemap")
    assert(!defined(invoker.deps), "swift_modulemap should not have 'deps'.")
    assert(!defined(invoker.public_deps),
           "swift_modulemap should not have 'public_deps'.")

    _modulemap_path = "${target_gen_dir}/${target_name}.modulemap"
    _modulemap_contents = [
      "// Generated by the swift_modulemap GN template for target ${target_name}.",
      "",
    ]

    _apinotes_deps = []
    _inputs = []
    _all_module_data = []

    foreach(module, invoker.modules) {
      assert(defined(module.name),
             "Each module in a swift_modulemap must have a 'name'")
      assert(defined(module.sources),
             "Each module in a swift_modulemap must have 'sources'")
      _inputs += module.sources
      _modulemap_contents += [ "module ${module.name} {" ]
      _rebased_headers = []
      foreach(header, module.sources) {
        _header_path_relative_to_modulemap = rebase_path(header, target_gen_dir)
        _rebased_headers += [ _header_path_relative_to_modulemap ]
        _modulemap_contents +=
            [ "  header \"${_header_path_relative_to_modulemap}\"" ]
      }

      # TODO: propagate API notes to groups
      _all_module_data += [
        {
          name = module.name
          sources = _rebased_headers
        },
      ]
      _modulemap_contents += [
        "  export *",
        "  requires cplusplus",
        "}",
        "",
      ]
      if (defined(module.apinotes)) {
        _inputs += module.apinotes
        _apinotes_target = "${target_name}_${module.name}_apinotes"
        _apinotes_deps += [ ":${_apinotes_target}" ]
        copy(_apinotes_target) {
          sources = module.apinotes
          outputs = [ "${target_gen_dir}/{{source_file_part}}" ]
        }
      }
    }

    config("${target_name}_config") {
      swiftflags = [ "-Xcc=-fmodule-map-file=" +
                     rebase_path(_modulemap_path, root_build_dir) ]

      # All the header files referenced in the generated modulemap need to be
      # explicitly propagated as "inputs" to swift targets that depend on the
      # modulemap so that ninja will know to rebuild the dependent swift modules
      # when an imported header is modified.
      # We also need to do this for apinotes because the dirty propagation from
      # `_apinotes_deps` could get pruned in incremental builds if the generated
      # modulemap file (the output of the swift_modulemap) remains identical but
      # an apinotes file has changed.
      inputs = _inputs
    }

    generated_file(target_name) {
      forward_variables_from(invoker,
                             "*",
                             TESTONLY_AND_VISIBILITY + [ "apinotes" ])
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
      outputs = [ _modulemap_path ]
      contents = _modulemap_contents

      # Any swift_source_set target with a direct deps on this modulemap will
      # inherit the config that sets the swift compiler flags to import this
      # modulemap.
      public_configs = [
        ":${target_name}_config",
        "//build/config/ios:swift_cxx_interop",
      ]

      deps = _apinotes_deps

      metadata = {
        swift_modulemap = _all_module_data
      }
    }
  }

  if (build_with_chromium) {
    # Template that groups several swift_modulemap target under a parent module.
    # This is a workaround that allows the swift compiler to import multiple
    # modules that define the same symbols due to the inclusion of common
    # headers.
    #
    # Arguments
    #
    #     module_name:
    #         string, name of the parent module create by this target
    #     deps:
    #         array of strings, list of child swift_modulemap targets to be
    #         added to the group.
    template("swift_modulemap_group") {
      assert(
          defined(invoker.module_name),
          "swift_modulemap_group targets must set the 'module_name' argument'")

      # It's important not to use public_deps in order to block the propagation
      # of public_configs from child modulemaps.
      assert(!defined(invoker.public_deps),
             "Do not use public_deps on swift_modulemap_group targets.")
      _metadata_path = "${target_gen_dir}/${target_name}/metadata.json"
      _modulemap_data_path =
          "${target_gen_dir}/${target_name}/modulemap_data.json"

      _metadata_target = "${target_name}_metadata"
      generated_file(_metadata_target) {
        forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
        outputs = [ _metadata_path ]
        contents = [
          "{",
          "  \"module_name\": \"${invoker.module_name}\",",
          "  \"target_name\": \"${target_name}\",",
          "  \"group_dir\": \"${target_gen_dir}/${target_name}\"",
          "}",
          "",
        ]
      }

      # Generate a file that contains metadata that describes the child
      # swift_modulemap targets by collecting metadata from downstream nodes in
      # the build graph.
      _modulemap_data_target = "${target_name}_modulemap_data"
      generated_file(_modulemap_data_target) {
        # Note: `invoker.deps` is forwarded to this target. Even though we
        # don't use the outputs from those targets, we do require the metadata
        # emitted by child swift_modulemap targets.
        forward_variables_from(invoker,
                               "*",
                               TESTONLY_AND_VISIBILITY + [ "module_name" ])
        forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
        outputs = [ _modulemap_data_path ]
        data_keys = [ "swift_modulemap" ]
        output_conversion = "json"
      }

      _group_modulemap_dir = "${target_gen_dir}/${target_name}"

      config("${target_name}_config") {
        swiftflags = [ "-Xcc=-fmodule-map-file=" +
                       rebase_path("${_group_modulemap_dir}/group.modulemap",
                                   root_build_dir) ]
      }

      # Generate a the group modulemap file
      json_data_generator("${target_name}_modulemap") {
        forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
        deps = [
          ":${_metadata_target}",
          ":${_modulemap_data_target}",
        ]
        sources = [
          _metadata_path,
          _modulemap_data_path,
        ]

        # We need to use a per-taget subdirectory because json_data_generator
        # uses an output file name that is named after the template file, which
        # can cause file name conflicts if there are several
        # swift_modulemap_group targets in the same directory.
        output_dir = _group_modulemap_dir
        templates = [ "//build/config/apple/group.modulemap.jinja" ]
        template_helper = "//build/config/apple/group_modulemap_helper.py"
      }

      group(target_name) {
        public_deps = [ ":${target_name}_modulemap" ]

        # Any swift_source_set target with a direct deps on this modulemap will
        # inherit the config that sets the swift compiler flags to import the
        # group modulemap.
        public_configs = [
          ":${target_name}_config",
          "//build/config/ios:swift_cxx_interop",
        ]
      }
    }
  }  # if (build_with_chromium)
}  # if (enable_swift_cxx_interop)
