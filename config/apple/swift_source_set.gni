# Copyright 2021 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/toolchain/apple/toolchain.gni")

# Defines a template for Swift source files. The default module_name
# of the target is the entire target label (without the leading //)
# with all "/" and ":" replaced with "_".
#
# Arguments
#
#   generate_intents
#       (optional) boolean, if true, intents definition in the source code
#       will be parsed when generating the final application (if it enable
#       the extraction of intents metadata), defaults to false.
#   module_name
#       (optional) string, name of this build target's top level swift module.
#       If not specified, a module name will be generated based on the target's
#       names
#
template("swift_source_set") {
  _generate_intents = false
  if (defined(invoker.generate_intents)) {
    _generate_intents = invoker.generate_intents
  }

  _target_name = target_name
  not_needed([ "_target_name" ])
  source_set(target_name) {
    forward_variables_from(invoker, "*", TESTONLY_AND_VISIBILITY)
    forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
    if (!defined(module_name)) {
      _target_label = get_label_info(":$_target_name", "label_no_toolchain")

      # Strip the // from the beginning of the label.
      _target_label = string_replace(_target_label, "//", "", 1)
      module_name =
          string_replace(string_replace(_target_label, "/", "_"), ":", "_")
    }

    # If generate_intents is true, write file $target_name.module_info.json
    # with information about the module used by extract_metadata.py script.
    if (_generate_intents) {
      _output_path = "$target_out_dir/$target_name"
      _swift_files = sources
      _const_files = []
      if (swift_whole_module_optimization) {
        _const_files += [ "$_output_path/$module_name.swiftconstvalues" ]
      } else {
        foreach(_source, sources) {
          _const_files += [ "$_output_path/" + get_path_info(_source, "name") +
                            ".swiftconstvalues" ]
        }
      }

      _module_info = {
        module_name = module_name
        swift_files = rebase_path(_swift_files, root_build_dir)
        const_files = rebase_path(_const_files, root_build_dir)
      }

      # Write the information for the module using `write_file(...)`.
      write_file("$_output_path.module_info.json", _module_info, "json")
    }

    # C++ and obj-C++ targets with a direct dependency on a swift_source_set
    # need to be able to indirectly include headers from the SDK.
    public_configs = [ "//build/config/ios:swift_cxx_interop_includes" ]
  }
}

set_defaults("swift_source_set") {
  configs = default_compiler_configs
}

if (enable_swift_cxx_interop) {
  # Template that defines a modulemap for exposing symbols from C++ sources to
  # swift
  #
  # Arguments
  #
  #   apinotes
  #       (optional) array of strings, paths of apinotes files
  #   module_name
  #       String, name of the build target's swift module.
  #   sources
  #       Array of strings, paths of C++ header files that declare the C++
  #       symbols to be imported into swift
  #   public_deps
  #       (optional) Array of strings, C++ targets that define the imported
  #       symbols. Not required if the symbols are all defined inline in the
  #       source headers.
  template("swift_modulemap") {
    assert(defined(invoker.module_name),
           "'module_name' must be defined in swift_modulemap")
    assert(defined(invoker.sources),
           "'sources' must be defined in swift_modulemap")
    _module_name = invoker.module_name

    _modulemap_path = "${target_gen_dir}/${target_name}.modulemap"

    _modulemap_contents = [
      "// Generated by the swift_modulemap GN template for target ${target_name}.",
      "",
      "module ${_module_name} {",
    ]
    foreach(header, invoker.sources) {
      _header_path_relative_to_modulemap = rebase_path(header, target_gen_dir)
      _modulemap_contents +=
          [ "  header \"${_header_path_relative_to_modulemap}\"" ]
    }
    _modulemap_contents += [
      "  export *",
      "}",
      "",
    ]

    config("${target_name}_config") {
      swiftflags = [ "-Xcc=-fmodule-map-file=" +
                     rebase_path(_modulemap_path, root_build_dir) ]
    }

    if (defined(invoker.apinotes)) {
      _apinotes_target = "${target_name}_apinotes"
      copy(_apinotes_target) {
        sources = invoker.apinotes
        outputs = [ "${target_gen_dir}/{{source_file_part}}" ]
      }
    }

    generated_file(target_name) {
      forward_variables_from(invoker,
                             "*",
                             TESTONLY_AND_VISIBILITY + [ "apinotes" ])
      forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
      outputs = [ _modulemap_path ]
      contents = _modulemap_contents

      # Any swift_source_set target with a direct deps on this modulemap will
      # inherit the config that sets the swift compiler flags to import this
      # modulemap.
      public_configs = [
        ":${target_name}_config",
        "//build/config/ios:swift_cxx_interop",
      ]

      if (defined(_apinotes_target)) {
        if (!defined(deps)) {
          deps = []
        }
        deps += [ ":$_apinotes_target" ]
      }
    }
  }
}  # if (enable_swift_cxx_interop)
